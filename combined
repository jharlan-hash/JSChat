/* ChatUtils.java */

import java.io.IOException;
import java.util.Scanner;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class ChatUtils {
    public static final String USER_PROMPT = "[you] ";
    public static final String EXIT_MESSAGE = "/exit";
    public static final String NICK_MESSAGE = "/nick";

    public static void main (String[] args) throws Exception {
        String mode;
        String ip;
        int port;

        if (args.length != 3) {
            System.out.println("Usage: ./build.sh <mode> <ip> <port>");
            System.exit(1);
        }

        mode = args[0];
        ip = args[1].equals("self") ? getLocalIP() : args[1];

        try {
            port = Integer.parseInt(args[2]);
        } catch (NumberFormatException e) {
            System.out.println("Please enter a valid port number.");
            port = -1;
            System.exit(1);
        }

        if (args[1].equals("self")) {
            System.out.println("IP Address: " + ip);
        }

        switch (mode) {
            case "con":
            try {
                Client.clientMode(ip, port);
            } catch (IOException e) {
                System.out.println("Connection failed - make sure the IP and port are correct.");
            }
                break;
            case "srv":
                Server.serverMode(port);
                break;
            default:
                System.out.println("Please enter a valid mode (con or srv)");
                break;
        }
    }

    public static byte[] getMessage(DataInputStream dataIn) throws IOException {
        try {
            // Read message length first
            int messageLength = dataIn.readInt();
            
            // Create buffer with exact message length
            byte[] message = new byte[messageLength];
            dataIn.readFully(message);
            
            return message;
        } catch (IOException e) {
            System.out.println("Error reading message: " + e.getMessage());
            throw e;
        }
    }

    public static void sendMessage(DataOutputStream dataOut, String message) throws IOException {
        // Send message length first
        byte[] messageBytes = message.getBytes();
        dataOut.writeInt(messageBytes.length);
        dataOut.write(messageBytes);
        dataOut.flush();
    }

    public static String sendMessage(DataOutputStream dataOut, Scanner sc) throws IOException {
        System.out.print(USER_PROMPT);
        String messageToSend = sc.nextLine();
        return messageToSend;
    }

    public static String parseCommands(String message, DataOutputStream dataOut ,String hostname) throws IOException {
        if (message.startsWith(ChatUtils.NICK_MESSAGE)) {
            String nickname = nickname(hostname, message);
            dataOut.writeUTF("\r{Server} " + hostname + " changed their nickname to " + nickname);
            return nickname;
        }

        return hostname;
    }

    public static String nickname (String hostname, String message){
        String[] messageArray = message.split(" ");
        hostname = messageArray[1];

        return hostname;
    }

    private static String getLocalIP() {
        try(final DatagramSocket socket = new DatagramSocket()){
            socket.connect(InetAddress.getByName("8.8.8.8"), 0);
            return socket.getLocalAddress().getHostAddress();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
/* Client.java */

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.net.InetSocketAddress;
import java.util.Scanner;

public class Client {
    public static void clientMode (String ip, int port) throws Exception {
        Socket socket = new Socket();
        Scanner sc = new Scanner(System.in);
        KeyPair keypair = RSA.generateRSAKeyPair();

        socket.connect(new InetSocketAddress(ip, port), 0);
        System.out.println("Connection successful!");

        DataInputStream dataIn = new DataInputStream(socket.getInputStream());
        DataOutputStream dataOut = new DataOutputStream(socket.getOutputStream());

        // Send public key with length prefix
        byte[] publicKeyBytes = keypair.getPublic().getEncoded();
        dataOut.writeInt(publicKeyBytes.length);
        dataOut.write(publicKeyBytes);
        System.out.println("Public key sent to server: " + publicKeyBytes.length + " bytes");

        // Receive connected public key with length prefix
        int connectedPublicKeyLength = dataIn.readInt();
        byte[] connectedPublicKeyBytes = new byte[connectedPublicKeyLength];
        dataIn.readFully(connectedPublicKeyBytes);

        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        PublicKey connectedPublicKey = keyFactory.generatePublic(new X509EncodedKeySpec(connectedPublicKeyBytes));


        Thread sendMessageToServer = createThread(dataIn, dataOut, sc, keypair, connectedPublicKey, socket, "send");
        Thread getMessageFromServer = createThread(dataIn, dataOut, sc, keypair, connectedPublicKey, socket, "get");

        getMessageFromServer.start();
        sendMessageToServer.start();

        getMessageFromServer.join();
        sendMessageToServer.join();

        shutdown(dataIn, dataOut, sc, socket);
        System.exit(0);
    }

    public static Thread createThread(DataInputStream dataIn, DataOutputStream dataOut, Scanner sc, KeyPair keypair, PublicKey connectedPublicKey, Socket socket, String mode) {
        Thread getMessageFromClient = new Thread(){
            public void run() {
                String hostname = socket.getInetAddress().getHostName();
                while (true) {
                    try {
                        if (mode.equals("send")) {
                            String message = ChatUtils.sendMessage(dataOut, sc);

                            hostname = ChatUtils.parseCommands(message, dataOut, hostname);

                            message = "\r[" + hostname + "] " + message;


                            if (message.equals(ChatUtils.EXIT_MESSAGE)){
                                //dataOut.writeUTF("\r{Server} " + hostname + " has left the chat - use /exit to leave");
                                dataIn.close();
                                dataOut.close();
                                sc.close();
                                Server.isRunning = false;
                                return;
                            }


                            if (!(message.startsWith("\r[" + hostname + "] /"))) { // checking if the message is a command
                                // Encrypt the message
                                byte[] encryptedMessage = RSA.encrypt(message, connectedPublicKey);
                                System.out.println("Encrypted message: " + encryptedMessage.toString());
                                dataOut.write(encryptedMessage);
                                dataOut.flush();
                            }


                        } else if (mode.equals("get")) {
                            byte[] encryptedMessage = ChatUtils.getMessage(dataIn);
                            String message = RSA.decrypt(encryptedMessage, keypair.getPrivate());

                            if (message == null || message.equals(ChatUtils.EXIT_MESSAGE)){
                                return;
                            }

                            System.out.println(message);
                            System.out.print(ChatUtils.USER_PROMPT);
                        } else {
                            System.out.println("Invalid mode argument.");
                            return;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                        return;
                    }
                    Thread.currentThread().interrupt();
                }
            }
        };

        return getMessageFromClient;
    }

    private static void shutdown(DataInputStream dataIn, DataOutputStream dataOut, Scanner sc, Socket socket) throws IOException {
        dataIn.close();
        dataOut.close();
        sc.close();
        socket.close();
    }
}
/* RSA.java */

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.nio.charset.StandardCharsets;
import javax.crypto.Cipher;

public class RSA{
    public static KeyPair generateRSAKeyPair() throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(3072);
        return keyPairGenerator.generateKeyPair();
    }

    public static byte[] encrypt(String plainText, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
    }

    public static String decrypt(byte[] cipherText, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        byte[] result = cipher.doFinal(cipherText);
        return new String(result);
    }
}

/* Server.java */

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

public class Server {
    public static boolean isRunning = true;

    public static void serverMode(int port) throws Exception {
        ServerSocket serverSocket = new ServerSocket(port);
        Scanner sc = new Scanner(System.in);

        System.out.println("Listening for clients...");
        Socket firstClientSocket = serverSocket.accept();
        System.out.println("Client connected");
        DataInputStream firstDataIn = new DataInputStream(firstClientSocket.getInputStream());
        DataOutputStream firstDataOut = new DataOutputStream(firstClientSocket.getOutputStream());

        // Read first client's public key with dynamic length
        int firstKeyLength = firstDataIn.readInt();
        byte[] firstPublicKeyBytes = new byte[firstKeyLength];
        firstDataIn.readFully(firstPublicKeyBytes);
        System.out.println("First public key read: " + firstKeyLength + " bytes");

        Socket secondClientSocket = serverSocket.accept();
        System.out.println("Second client connected");
        firstDataOut.writeUTF("\rSecond user connected");
        DataInputStream secondDataIn = new DataInputStream(secondClientSocket.getInputStream());
        DataOutputStream secondDataOut = new DataOutputStream(secondClientSocket.getOutputStream());

        // Read second client's public key with dynamic length
        int secondKeyLength = secondDataIn.readInt();
        byte[] secondPublicKeyBytes = new byte[secondKeyLength];
        secondDataIn.readFully(secondPublicKeyBytes);
        System.out.println("Second public key read: " + secondKeyLength + " bytes");

        // Send public keys with length
        secondDataOut.writeInt(firstPublicKeyBytes.length);
        secondDataOut.write(firstPublicKeyBytes);
        firstDataOut.writeInt(secondPublicKeyBytes.length);
        firstDataOut.write(secondPublicKeyBytes);

        Thread getMessageFromFirstClient = createThread(firstClientSocket, firstDataIn, secondDataOut);
        Thread getMessageFromSecondClient = createThread(secondClientSocket, secondDataIn, firstDataOut);

        getMessageFromFirstClient.start();
        getMessageFromSecondClient.start();

        getMessageFromFirstClient.join();
        getMessageFromSecondClient.join();

        shutdown(firstDataIn, firstDataOut, secondDataIn, secondDataOut, sc, firstClientSocket, secondClientSocket, serverSocket);
    }

    private static Thread createThread(Socket clientSocket, DataInputStream dataIn, DataOutputStream dataOut) {
        return new Thread(() -> {
            while (isRunning) {
                try {
                    byte[] message = ChatUtils.getMessage(dataIn);
                    if (message == null) break;
                    
                    dataOut.writeInt(message.length);
                    dataOut.write(message);
                    dataOut.flush();
                } catch (IOException e) {
                    System.out.println("Error in message routing: " + e.getMessage());
                    break;
                }
            }
        });
    }

    private static void shutdown(

        DataInputStream firstDataIn, 
        DataOutputStream firstDataOut, 
        DataInputStream secondDataIn, 
        DataOutputStream secondDataOut, 
        Scanner sc, 
        Socket firstClientSocket, 
        Socket secondClientSocket, 
        ServerSocket serverSocket
    ) throws IOException {
        System.out.println("Shutting down server...");
        closeQuietly(firstDataIn);
        closeQuietly(firstDataOut);
        closeQuietly(secondDataIn);
        closeQuietly(secondDataOut);
        closeQuietly(sc);
        closeQuietly(firstClientSocket);
        closeQuietly(secondClientSocket);
        closeQuietly(serverSocket);
        System.exit(0);
    }

    private static void closeQuietly(AutoCloseable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (Exception ignored) {}
        }
    }
}
