package com.jacksovern.Server;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;

public class Server {
    private static int port = 1000;
    private static ServerClient client1;
    private static ServerClient client2;

    public Server(int portNumber) {
        port = portNumber;
        try {
            ServerSocket serverSocket = new ServerSocket(port);
            client1 = new ServerClient(serverSocket.accept()); // this will eventually be a loop
            client2 = new ServerClient(serverSocket.accept());
            serverSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                client1.getDataIn().close();
                client1.getDataOut().close();
                client2.getDataIn().close();
                client2.getDataOut().close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // this whole file needs to not be static
    public static void serverMode(int port) throws IOException, InterruptedException, Exception {
        // Socket clientSocket1 = serverSocket.accept();
        // System.out.println("Client connected");
        // DataInputStream client1.getDataIn() = new
        // DataInputStream(clientSocket1.getInputStream());
        // DataOutputStream client1.getDataOut() = new
        // DataOutputStream(clientSocket1.getOutputStream());

        System.out.println("First public key read");
        byte[] firstPublicKeyBytes = ServerUtils.readKeyBytes(client1.getDataIn(), 422);

        // Socket clientSocket2 = serverSocket.accept();
        // System.out.println("Second client connected");
        // client1.getDataOut().writeUTF("\rSecond user connected");
        // DataInputStream client2.getDataIn() = new
        // DataInputStream(clientSocket2.getInputStream());
        // DataOutputStream client2.getDataOut() = new
        // DataOutputStream(clientSocket2.getOutputStream());

        byte[] secondPublicKeyBytes = ServerUtils.readKeyBytes(client2.getDataIn(), 422);
        System.out.println("Second public key read");

        client2.getDataOut().write(firstPublicKeyBytes);
        client1.getDataOut().write(secondPublicKeyBytes);

        byte[] AESKeyBytes = new byte[384];
        if (client1.getDataIn().read(AESKeyBytes) < 384) {
            System.out.println("AES key not received in full.");
        }

        client1.getDataOut().write(AESKeyBytes);
        client2.getDataOut().write(AESKeyBytes);
        client1.getDataOut().flush();
        client2.getDataOut().flush();

        client2.getDataIn().readNBytes(384); // discarding unused AES key

        Thread thread1 = createThread(client1.getDataIn(), client2.getDataOut());
        Thread thread2 = createThread(client2.getDataIn(), client1.getDataOut());

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        // this function might be the worst part tbh
    }

    // actually this is the worst
    // why is it not a class that implements Runnable
    public static Thread createThread(DataInputStream dataIn, DataOutputStream dataOut) {
        Thread clientThread = new Thread() {
            public void run() {
                while (ServerUtils.serverIsRunning) {
                    try {
                        int messageLength = dataIn.readInt(); //
                        if (messageLength <= 0) {
                            continue;
                        }

                        byte[] message = new byte[messageLength];
                        int bytesRead = 0;
                        while (bytesRead < messageLength) {
                            int result = dataIn.read(message, bytesRead, messageLength - bytesRead);
                            if (result == -1) {
                                break;
                            }
                            bytesRead += result;
                        }

                        dataOut.writeInt(messageLength); // shouldnt this be a custom class?
                        // seriously, why are we using byte arrays for everything & not classes
                        dataOut.write(message, 0, messageLength);
                        dataOut.flush();
                    } catch (IOException e) {
                        System.out.println("Client disconnected");
                        ServerUtils.serverIsRunning = false; // why is this a global variable
                        // what does it even do
                        return;

                    }
                }
            }
        };

        return clientThread;
    }

}
